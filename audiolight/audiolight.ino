#include "EspMQTTClient.h"
#include <ArduinoJson.h>
#include <Adafruit_NeoPixel.h>
#include <WiFiUdp.h>

uint8_t heat_lut[256][3] = { {0x30,0x12,0x3B},{0x31,0x15,0x42},{0x32,0x18,0x4A},{0x34,0x1B,0x51},{0x35,0x1E,0x58},{0x36,0x21,0x5F},{0x37,0x23,0x65},{0x38,0x26,0x6C},{0x39,0x29,0x72},{0x3A,0x2C,0x79},{0x3B,0x2F,0x7F},{0x3C,0x32,0x85},{0x3C,0x35,0x8B},{0x3D,0x37,0x91},{0x3E,0x3A,0x96},{0x3F,0x3D,0x9C},{0x40,0x40,0xA1},{0x40,0x43,0xA6},{0x41,0x45,0xAB},{0x41,0x48,0xB0},{0x42,0x4B,0xB5},{0x43,0x4E,0xBA},{0x43,0x50,0xBE},{0x43,0x53,0xC2},{0x44,0x56,0xC7},{0x44,0x58,0xCB},{0x45,0x5B,0xCE},{0x45,0x5E,0xD2},{0x45,0x60,0xD6},{0x45,0x63,0xD9},{0x46,0x66,0xDD},{0x46,0x68,0xE0},{0x46,0x6B,0xE3},{0x46,0x6D,0xE6},{0x46,0x70,0xE8},{0x46,0x73,0xEB},{0x46,0x75,0xED},{0x46,0x78,0xF0},{0x46,0x7A,0xF2},{0x46,0x7D,0xF4},{0x46,0x7F,0xF6},{0x46,0x82,0xF8},{0x45,0x84,0xF9},{0x45,0x87,0xFB},{0x45,0x89,0xFC},{0x44,0x8C,0xFD},{0x43,0x8E,0xFD},{0x42,0x91,0xFE},{0x41,0x93,0xFE},{0x40,0x96,0xFE},{0x3F,0x98,0xFE},{0x3E,0x9B,0xFE},{0x3C,0x9D,0xFD},{0x3B,0xA0,0xFC},{0x39,0xA2,0xFC},{0x38,0xA5,0xFB},{0x36,0xA8,0xF9},{0x34,0xAA,0xF8},{0x33,0xAC,0xF6},{0x31,0xAF,0xF5},{0x2F,0xB1,0xF3},{0x2D,0xB4,0xF1},{0x2B,0xB6,0xEF},{0x2A,0xB9,0xED},{0x28,0xBB,0xEB},{0x26,0xBD,0xE9},{0x25,0xC0,0xE6},{0x23,0xC2,0xE4},{0x21,0xC4,0xE1},{0x20,0xC6,0xDF},{0x1E,0xC9,0xDC},{0x1D,0xCB,0xDA},{0x1C,0xCD,0xD7},{0x1B,0xCF,0xD4},{0x1A,0xD1,0xD2},{0x19,0xD3,0xCF},{0x18,0xD5,0xCC},{0x18,0xD7,0xCA},{0x17,0xD9,0xC7},{0x17,0xDA,0xC4},{0x17,0xDC,0xC2},{0x17,0xDE,0xBF},{0x18,0xE0,0xBD},{0x18,0xE1,0xBA},{0x19,0xE3,0xB8},{0x1A,0xE4,0xB6},{0x1B,0xE5,0xB4},{0x1D,0xE7,0xB1},{0x1E,0xE8,0xAF},{0x20,0xE9,0xAC},{0x22,0xEB,0xA9},{0x24,0xEC,0xA6},{0x27,0xED,0xA3},{0x29,0xEE,0xA0},{0x2C,0xEF,0x9D},{0x2F,0xF0,0x9A},{0x32,0xF1,0x97},{0x35,0xF3,0x94},{0x38,0xF4,0x91},{0x3B,0xF4,0x8D},{0x3F,0xF5,0x8A},{0x42,0xF6,0x87},{0x46,0xF7,0x83},{0x4A,0xF8,0x80},{0x4D,0xF9,0x7C},{0x51,0xF9,0x79},{0x55,0xFA,0x76},{0x59,0xFB,0x72},{0x5D,0xFB,0x6F},{0x61,0xFC,0x6C},{0x65,0xFC,0x68},{0x69,0xFD,0x65},{0x6D,0xFD,0x62},{0x71,0xFD,0x5F},{0x74,0xFE,0x5C},{0x78,0xFE,0x59},{0x7C,0xFE,0x56},{0x80,0xFE,0x53},{0x84,0xFE,0x50},{0x87,0xFE,0x4D},{0x8B,0xFE,0x4B},{0x8E,0xFE,0x48},{0x92,0xFE,0x46},{0x95,0xFE,0x44},{0x98,0xFE,0x42},{0x9B,0xFD,0x40},{0x9E,0xFD,0x3E},{0xA1,0xFC,0x3D},{0xA4,0xFC,0x3B},{0xA6,0xFB,0x3A},{0xA9,0xFB,0x39},{0xAC,0xFA,0x37},{0xAE,0xF9,0x37},{0xB1,0xF8,0x36},{0xB3,0xF8,0x35},{0xB6,0xF7,0x35},{0xB9,0xF5,0x34},{0xBB,0xF4,0x34},{0xBE,0xF3,0x34},{0xC0,0xF2,0x33},{0xC3,0xF1,0x33},{0xC5,0xEF,0x33},{0xC8,0xEE,0x33},{0xCA,0xED,0x33},{0xCD,0xEB,0x34},{0xCF,0xEA,0x34},{0xD1,0xE8,0x34},{0xD4,0xE7,0x35},{0xD6,0xE5,0x35},{0xD8,0xE3,0x35},{0xDA,0xE2,0x36},{0xDD,0xE0,0x36},{0xDF,0xDE,0x36},{0xE1,0xDC,0x37},{0xE3,0xDA,0x37},{0xE5,0xD8,0x38},{0xE7,0xD7,0x38},{0xE8,0xD5,0x38},{0xEA,0xD3,0x39},{0xEC,0xD1,0x39},{0xED,0xCF,0x39},{0xEF,0xCD,0x39},{0xF0,0xCB,0x3A},{0xF2,0xC8,0x3A},{0xF3,0xC6,0x3A},{0xF4,0xC4,0x3A},{0xF6,0xC2,0x3A},{0xF7,0xC0,0x39},{0xF8,0xBE,0x39},{0xF9,0xBC,0x39},{0xF9,0xBA,0x38},{0xFA,0xB7,0x37},{0xFB,0xB5,0x37},{0xFB,0xB3,0x36},{0xFC,0xB0,0x35},{0xFC,0xAE,0x34},{0xFD,0xAB,0x33},{0xFD,0xA9,0x32},{0xFD,0xA6,0x31},{0xFD,0xA3,0x30},{0xFE,0xA1,0x2F},{0xFE,0x9E,0x2E},{0xFE,0x9B,0x2D},{0xFE,0x98,0x2C},{0xFD,0x95,0x2B},{0xFD,0x92,0x29},{0xFD,0x8F,0x28},{0xFD,0x8C,0x27},{0xFC,0x89,0x26},{0xFC,0x86,0x24},{0xFB,0x83,0x23},{0xFB,0x80,0x22},{0xFA,0x7D,0x20},{0xFA,0x7A,0x1F},{0xF9,0x77,0x1E},{0xF8,0x74,0x1C},{0xF7,0x71,0x1B},{0xF7,0x6E,0x1A},{0xF6,0x6B,0x18},{0xF5,0x68,0x17},{0xF4,0x65,0x16},{0xF3,0x63,0x15},{0xF2,0x60,0x14},{0xF1,0x5D,0x13},{0xEF,0x5A,0x11},{0xEE,0x58,0x10},{0xED,0x55,0x0F},{0xEC,0x52,0x0E},{0xEA,0x50,0x0D},{0xE9,0x4D,0x0D},{0xE8,0x4B,0x0C},{0xE6,0x49,0x0B},{0xE5,0x46,0x0A},{0xE3,0x44,0x0A},{0xE2,0x42,0x09},{0xE0,0x40,0x08},{0xDE,0x3E,0x08},{0xDD,0x3C,0x07},{0xDB,0x3A,0x07},{0xD9,0x38,0x06},{0xD7,0x36,0x06},{0xD6,0x34,0x05},{0xD4,0x32,0x05},{0xD2,0x30,0x05},{0xD0,0x2F,0x04},{0xCE,0x2D,0x04},{0xCB,0x2B,0x03},{0xC9,0x29,0x03},{0xC7,0x28,0x03},{0xC5,0x26,0x02},{0xC3,0x24,0x02},{0xC0,0x23,0x02},{0xBE,0x21,0x02},{0xBB,0x1F,0x01},{0xB9,0x1E,0x01},{0xB6,0x1C,0x01},{0xB4,0x1B,0x01},{0xB1,0x19,0x01},{0xAE,0x18,0x01},{0xAC,0x16,0x01},{0xA9,0x15,0x01},{0xA6,0x14,0x01},{0xA3,0x12,0x01},{0xA0,0x11,0x01},{0x9D,0x10,0x01},{0x9A,0x0E,0x01},{0x97,0x0D,0x01},{0x94,0x0C,0x01},{0x91,0x0B,0x01},{0x8E,0x0A,0x01},{0x8B,0x09,0x01},{0x87,0x08,0x01},{0x84,0x07,0x01},{0x81,0x06,0x02},{0x7D,0x05,0x02},{0x7A,0x04,0x02} };

#define LED_PIN     4
#define LED_COUNT  50
#define BRIGHTNESS 100 // Set BRIGHTNESS (max = 255)
#define UDP_PORT 4210

#define PERIODIC_MESSAGE_INTERVAL     30*1000 /*!< periodicity of messages in milliseconds */
#define DSP_VOLUME_CHANNELS_NUM       24 /*!< num address in memory (indirect memory table) */


#define MIN_MAX_VALUES_NUM 50

uint8_t run_flag = 0;

uint8_t mqtt_mutex = 0;
unsigned long current_ms = 0;
unsigned long previous_ms = 0;

uint8_t incoming_packet[255];
uint8_t incoming_packet_length = 0;

uint16_t volumes[DSP_VOLUME_CHANNELS_NUM];
uint16_t normalized_volumes[DSP_VOLUME_CHANNELS_NUM];
uint16_t min_values[MIN_MAX_VALUES_NUM];
uint16_t max_values[MIN_MAX_VALUES_NUM];

uint8_t max_first_flag = 0;
uint8_t min_first_flag = 0;


Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_RGB + NEO_KHZ400);
WiFiUDP udp_client;


EspMQTTClient mqtt_client(
  "IoT_Dobbi",            //WiFi name
  "canned-ways-incense",  //WiFi password
  "192.168.88.111",       //MQTT server address
  "", "",                 //MQTT username and password
  "ESP8266_audiolight",   //Client name
  1883                    //MQTT port
);

//---------------------------------------------//

uint16_t map(uint16_t x, uint16_t in_min, uint16_t in_max, uint16_t out_min, uint16_t out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


void PrintHex8(uint8_t *data, uint8_t length) // prints 8-bit data in hex
{
  char tmp[length*2+1];
  byte first;
  byte second;
  for (int i=0; i<length; i++) {
    first = (data[i] >> 4) & 0x0f;
    second = data[i] & 0x0f;
    tmp[i*2] = first+48;
    tmp[i*2+1] = second+48;
    if (first > 9) tmp[i*2] += 39;
    if (second > 9) tmp[i*2+1] += 39;
  }
  tmp[length*2] = 0;
  Serial.print(tmp);
}

uint16_t find_maximum(uint16_t a[], uint8_t n) {
  uint8_t c, index = 0;
  for (c = 1; c < n; c++)
    if (a[c] > a[index])
      index = c;
  return index;
}

uint16_t find_minimum(uint16_t a[], uint8_t n) {
  uint8_t c, index = 0;
  for (c = 1; c < n; c++)
    if (a[c] < a[index])
      index = c;
  return index;
}


uint16_t update_min_ring_buffer(uint16_t min) {
  for (uint8_t i = 0; i < MIN_MAX_VALUES_NUM - 1; i++) {
    if (min_first_flag == 0) {
      min_values[i] = min;
    } else {
      min_values[i] = min_values[i + 1];
    }
    min_values[MIN_MAX_VALUES_NUM - 1] = min;
  }
  min_first_flag = 1;
  return min_values[find_minimum(min_values, MIN_MAX_VALUES_NUM)];
}


uint16_t update_max_ring_buffer(uint16_t max) {
  if (max != 0) {
    for (uint8_t i = 0; i < MIN_MAX_VALUES_NUM - 1; i++) {
      if (max_first_flag == 0) {
        max_values[i] = max;
      } else {
        max_values[i] = max_values[i + 1];
      }
    }
    max_values[MIN_MAX_VALUES_NUM - 1] = max;
  }
  max_first_flag = 1;
  return max_values[find_maximum(max_values, MIN_MAX_VALUES_NUM)];
}



void power_message_received(const String& topic, const String& message) {
  DynamicJsonDocument rta_settings(1024);
  DeserializationError error = deserializeJson(rta_settings, message);

  if (rta_settings["period"].as<int>() == 0) {
    run_flag = 0;
  }
  else {
    run_flag = 1;
  }
}


void onConnectionEstablished()
{
  mqtt_client.subscribe("dionis/rta_send_settings/set", power_message_received);
  mqtt_client.publish("audiolight/status", "audiolight module started");
}


//---------------------------------------------//



void colorWipe(uint32_t color) {
  for(int i=0; i < strip.numPixels(); i++) {
    strip.setPixelColor(i, color);
  }
  strip.show();
}

void color_update() {
  uint8_t color_effect = 1;
  if (color_effect == 0) {
    for (uint8_t i = 0; i < DSP_VOLUME_CHANNELS_NUM; i++) {
      uint8_t current_value = normalized_volumes[i];
      strip.setPixelColor(i*2-1, strip.Color(heat_lut[current_value][0], heat_lut[current_value][1], heat_lut[current_value][2]));
      strip.setPixelColor(i*2, strip.Color(heat_lut[current_value][0], heat_lut[current_value][1], heat_lut[current_value][2]));
    }
  }
  if (color_effect == 1) {
    for (uint8_t i = 0; i < DSP_VOLUME_CHANNELS_NUM; i++) {
      uint8_t current_value = normalized_volumes[i];
      uint8_t current_color[3] = {
        heat_lut[i*9+4][0]*current_value/256,
        heat_lut[i*9+4][1]*current_value/256,
        heat_lut[i*9+4][2]*current_value/256
        };

      strip.setPixelColor(i*2-1, strip.Color(current_color[0], current_color[1], current_color[2]));
      strip.setPixelColor(i*2, strip.Color(current_color[0], current_color[1], current_color[2]));
    }
  }
  strip.show();
}

void incoming_udp_packet() {
  uint32_t volumes_32t[DSP_VOLUME_CHANNELS_NUM];

  for (uint8_t i = 0; i < DSP_VOLUME_CHANNELS_NUM; i++) {
    uint32_t volume = 0x00 | (0x00 << 8) | (incoming_packet[i*2 + 1] << 16) | (incoming_packet[i*2 + 0] << 24);
    volumes[i] = volume/1000000;
  }

  Serial.print("R: ");
  for (uint8_t i = 0; i < DSP_VOLUME_CHANNELS_NUM; i++) {
    Serial.print(volumes[i]);
    Serial.print(",");
  }
  Serial.print("\n");


  uint16_t current_min_value = volumes[find_minimum(volumes, DSP_VOLUME_CHANNELS_NUM)];
  uint16_t current_max_value = volumes[find_maximum(volumes, DSP_VOLUME_CHANNELS_NUM)];
  uint16_t min_value = update_min_ring_buffer(current_min_value);
  uint16_t max_value = update_max_ring_buffer(current_max_value);

  Serial.print("CM: ");
  Serial.print(current_min_value);
  Serial.print(",");
  Serial.print(current_max_value);
  Serial.print(" AM:");
  Serial.print(min_value);
  Serial.print(",");
  Serial.print(max_value);
  Serial.print("\n");


  if (max_value == min_value) {
    Serial.print("Max=Min, no data\n");
    colorWipe(strip.Color(0, 0, 0));
    return;
  }

  for (uint8_t i = 0; i < DSP_VOLUME_CHANNELS_NUM; i++) {
    uint16_t current_value = volumes[i];
    normalized_volumes[i] = map(current_value, min_value, max_value, 0, 255);
  }

  Serial.print("N: ");
  for (uint8_t i = 0; i < DSP_VOLUME_CHANNELS_NUM; i++) {
    Serial.print(normalized_volumes[i]);
    Serial.print(",");
  }
  Serial.print("\n");

  Serial.print(".");
  color_update();
}

void setup()
{
  Serial.begin(115200);
  mqtt_client.enableDebuggingMessages();
  strip.begin();
  strip.show();
  strip.setBrightness(BRIGHTNESS);
  colorWipe(strip.Color(0, 0, 0));
  udp_client.begin(UDP_PORT);
}

void loop()
{
  mqtt_client.loop();
  current_ms = millis();

  if (run_flag == 1) {
    if (udp_client.parsePacket()) {
      incoming_packet_length = udp_client.read(incoming_packet, DSP_VOLUME_CHANNELS_NUM*2);
      incoming_udp_packet();
    }
  }
  else {
    colorWipe(strip.Color(0, 0, 0));
  }

  if (current_ms - previous_ms >= PERIODIC_MESSAGE_INTERVAL) { //TODO гасить, если больше секунды нет данных
    previous_ms = current_ms;
    //Serial.println("Publishing to MQTT periodic message");
    //mqtt_client.publish("audiolight/status", "ok");
  }
}
